# JPA 소개

## SQL을 직접 다룰 때 발생하는 문제점

- 관계형 데이터베이스는 가장 대중적이고 신뢰할 만한 안전한 데이터 저장소
- 자바로 개발하는 대부분의 애플리케이션은 대부분 관계형 데이터베이스를 사용

### 반복 X 3

- 회원 조회 기능
    1. 회원 조회용 `SQL` 작성
    2. `JDBC API` 를 사용해서 `SQL`을 실행
    3. 조회결과를 객체로 매핑
- 회원 등록 기능
    1. 회원 등록용 `SQL` 작성
    2. 객체의 값을 꺼내서 등록 `SQL`에 전달
    3. `JDBC API`를 사용해서 `SQL`을 실행
- 회원을 수정하고 삭제하는 기능도 `SQL`을 작성하고 `JDBC API`를 사용하는 비슷한 일을 반복

- 데이터 베이스는 객체 구조와는 다른 데이터 중심의 구조를 가지므로 객체를 데이터베이스에 직접 저장하거나 조회할 수 없음
- 개발자가 객체지향 애플리케이션과 데이터베이스 중간에서 `SQL`과 `JDBC API`를 사용해서 변환 작업을 직접 해주어야함

### SQL에 의존적인 개발

- 회원 객체에 tel 필드 추가 → INSERT SQL 수정 → 객체의 연락처 값을 꺼내서 등록 SQL에 전달 → 조회용 SQL 수정 → 조회결과를 객체에 추가로 매핑 → UPDATE SQL 과 MemberDAO.update()의 코드 변경 ...
- 데이터 접근 계층을 사용해서  `SQL`을 숨겨도 어쩔 수 없이 `DAO`를 열어서 어떤 `SQL`이 실행되는지 확인해야 하는 문제
- `SQL`과의 강한 의존관계 때문에 객체에 필드를 하나 추가할 때도 `DAO`의 `CRUD`코드와 `SQL` 대부분을 변경해야 하는 문제

- **문제점 요약**
    - 진정한 의미의 계층 분할이 어렵다
    - 엔티티를 신뢰할 수 없다
    - `SQL`에 의존적인 개발을 피하기 어렵다

### JPA와 문제 해결

- 개발자가 직접 `SQL`을 작성하는 것이 아니라 `JPA`가 제공하는 `API`를 사용하면 됨
- `JPA`가 개발자 대신에 적절한 `SQL`을 생성해서 데이터베이스에 전달
- **CRUD API**
    - 저장기능 persist() : INSERT SQL
    - 조회기능 find() : SELECT SQL
    - 수정기능 : JPA는 별도의 수정 메소드를 제공하지는 않지만 객체를 조회해서 값을 변경만 하면 트랜잭션을 커밋할 때 UPDATE SQL이 전달

## 패러다임의 불일치

- 복잡성을 제어하지 못하면 결국 유지보수하기 어려운 애플리케이션이 됨
- 객체지향 프로그래밍은 추상화, 캡슐화, 정보은닉, 상속, 다형성 등 시스템의 복잡성을 제어할 수 있는 다양한 장치를 제공
- 객체가 단순하면 객체의 모든 속성 값을 꺼내서 파일이나 데이터베이스에 저장하면 되지만, 부모 객체를 상속받았거나, 다른 객체를 참조하고 있다면 객체의 상태를 저장하기는 쉽지않다
- 자바는 이런 문제까지 고려해서 객체를 파일로 저장하는 직렬화 기능과 저장된 파일을 객체로 복구하는 역 직렬화 기능을 지원하지만, 직렬화된 객체를 검색하기 어렵다는 문제가 있어 현실성이 없다
- 객체와 관계형 데이터베이스는 지향하는 목적이 서로 다르므로 둘의 기능과 표현방법도 다름
    
    → **객체와 관계형 데이터베이스의 패러다임 불일치 문제**
    

- 객체는 `상속`이라는 기능을 가지고 있지만 테이블은 `상속`이라는 기능이 없다
    - 슈퍼타입-서브타입 관계를 사용하면 객체 상속과 가장 유사한 형태로 테이블을 설계할 수 있음

- **JPA와 상속**
    
    → 개발자는 마치 자바 컬렉션에 객체를 저장하듯이 JPA에게 객체를 저장하면 된다
    

### 연관관계

- 객체는 참조를 사용해서 다른 객체와 연관관계를 가지고 참조에 접근해서 연관된 객체를 조회한다
- 테이블은 외래 키를 사용해서 다른 테이블과 연관관계를 가지고 조인을 사용해서 연관된 테이블을 조회한다
- 객체는 참조가 있는 방향으로만 조회할 수 있다
- 객체 모델은 외래 키가 필요 없고 단지 참조만 있으면 되는 반면, 테이블은 참조가 필요 없고 외래 키만 있으면 된다 → 결국, 개발자가 중간에서 변환역할을 해야 함

- SQL을 직접 다루면 처음 실행하는 SQL에 따라 객체 그래프를 어디까지 탐색할 수 있는지 정해진다
- 어디까지 객체 그래프 탐색이 가능한지 알아보려면 데이터 접근 계층인 DAO를 열어서 SQL을 직접 확인해야 한다 → 엔티티가 SQL에 논리적으로 종속되어서 발생하는 문제

- **JPA와 객체 그래프 탐색**
    - 지연로딩 : 실제 객체를 사용하는 시점까지 데이터베이스 조회를 미룸

### 비교

- 데이터베이스는 기본키(PK)의 값으로 각 ROW를 구분
- 객체는 동일성 비교(`Identity`) 와 동등성 비교(`Equality`) 라는 두가지 비교 방법이 있다
    - 동일성 비교는 == 비교 → 객체 인스터스의 주소 값을 비교
    - 동등성 비교 → `equals()` 메소드를 사용해서 객체 내부의 값을 비교

→ 테이블의 로우를 구분하는 방법과 객체를 구분하는 방법에는 차이가 있다

- 같은 데이터 베이스 로우에서 조회해도 객체를 두 번 조회하면 동일성 비교에는 실패한다

- **JPA와 비교**
    - JPA는 같은 `트랜잭션`일 때 같은 객체가 조회되는 것을 보장한다

### 정리

- 객체 모델과 관계형 데이터베이스 모델은 지향하는 `패러다임`이 서로 다르다
    
    → 문제는 이 `패러다임의 차이`를 극복하려고 개발자가 너무 많은 시간과 코드를 소비
    
- JPA는 `패러다임의 불일치` 문제를 해결해주고 정교한 객체 모델링을 유지하게 도와준다

## JPA란 무엇인가?

- JPA(Java Persistence API) : 자바 진영의 ORM 기술 표준
    - 애플리케이션과 JDBC 사이에서 동작

    ![image](https://user-images.githubusercontent.com/31034469/158940459-eb8bdc74-9b2c-48f5-b227-6584398a9b00.png)

- ORM(Object-Relational Mapping) : 객체와 관계형 데이터베이스를 매핑
    - ORM 프레임워크는 객체와 테이블을 매핑해서 패러다임의 불일치 문제를 개발자 대신 해결해 줌
    
    ![image](https://user-images.githubusercontent.com/31034469/158940481-41758373-ab28-4b61-9734-5bf397cc83c0.png)
    

- 객체 측면에서는 정교한 객체 모델링을 할 수 있고 관계형 데이터베이스는 데이터베이스에 맞도록 모델링만 하면 됨
    
    → 개발자는 데이터 중심인 관계형 데이터베이스를 사용해도 객체지향 애플리케이션 개발에 집중할 수 있음
    
- `Hibernate` 는 거의 대부분의 패러다임 불일치 문제를 해결해주는 성숙한 ORM 프레임워크다

### JPA 소개

- JPA는 자바 ORM 기술에 대한 API 표준 명세 → 인터페이스를 모아둔 것
- JPA를 사용하려면 JPA를 구현한 ORM 프레임워크를 선택 → 하이버네이트가 가장 대중적
- JPA 표준은 일반적이고 공통적인 기능의 모음

### 왜 JPA를 사용해야 하는가?

- 생산성
    - JPA를 사용하면 자바 컬렉션에 객체를 저장하듯이 JPA에게 저장할 객체를 전달하면 됨
    - CRUD용 SQL을 개발자가 직접 작성하지 않아도 됨
    - 데이터베이스 설계 중심의 패러다임을 객체 설계 중심으로 역전
- 유지보수
    - 필드를 추가하거나 삭제해도 수정해야 할 코드가 줄어듬 → 유지보수해야하는 코드 수가 줄어듬
    - 패러다임 불일치 문제를 해결해주므로 객체지향 언어가 가진 장점들을 활용해서 유연하고 유지보수하기 좋은 도메인 모델을 편리하게 설계할 수 있음
- 패러다임의 불일치 해결
    - 책 전반에 걸쳐서 JPA가 패러다임의 불일치 문제를 어떻게 해결하는지 자세히 알아봄!!
- 성능
    - JPA는 애플리케이션과 데이터베이스 사이에서 다양한 성능 최적화 기회를 제공
    - 애플리케이션과 데이터베이스 사이에 계층이 하나 더 있으면 최적화 관점에서 시도해 볼 수 있는 것들이 많음
- 데이터 접근 추상화와 벤더 독립성
    - 관계형 데이터베이스는 같은 기능도 벤더마다 사용법이 다른 경우가 많음
    - 애플리케이션은 처음 선택한 데이터베이스 기술에 종속되고 다른 데이터베이스로 변경하기가 매우 어려움
    - JPA는 애플리케이션과 데이터 베이스 사이에 추상화된 데이터 접근 계층을 제공해서 애플리케이션이 특정 데이터베이스 기술에 종속되지 않도록 함
- 표준
    - 표준을 사용하면 다른 구현 기술로 손쉽게 변경 가능

**📌 JPQL로 대상 직접 조회**<br/>
가장 간단한 방법은 처음부터 자식 타입을 직접 조회해서 필요한 연산을 하는 것이다.
- 이 방법을 사용하면 다형성을 활용할 수 없다.

**📌 프록시 벗기기**<br/>
Hibernate가 제공하는 기능을 사용해 프록시에서 원본 엔티티를 가져온다.

```java
  ...

  Item item = orderItem.getItem();
  Item unProxyItem = unProxy(item);

  if (unProxyItem instanceof Book) {
    System.out.println("proxyItem instanceof Book");
    Book book = (Book) unProxyItem;
    System.out.println("책 저자 = " + book.getAuthor());
  }

  Assert.assertTrue(item != unProxyItem);
}

// Hibernate가 제공하는 프록시에서 원본 엔티티를 찾는 기능을 사용하는 메소드
public static <T> T unProxy(Object entity) {
  if (entity instanceof HibernateProxy) {
    entity = ((HibernateProxy) entity)
              .getHibernateLazyInitializer()
              .getImplementation();
  }

  return (T) entity;
}
```
- 영속성 컨텍스트는 한 번 프록시로 노출한 엔티티는 계속 프록시로 노출한다. (영속 엔티티의 동일성 보장, 클라이언트는 프록시인지 아닌지 구분하지 않고 사용 가능)
- 이 방법은 프록시에서 원본 엔티티를 직접 꺼내 **프록시와 원본 엔티티의 동일성 비교가 실패**한다는 문제점이 있다.

**📌 기능을 위한 별도의 인터페이스 제공**<br/>
<img src="https://leejaedoo.github.io/assets/img/proxy3.jpeg" width="40%">
```java
public interface TitleView {
  String getTitle();
}
```
- 특정 기능을 제공하는 인터페이스를 정의한다.
- 자식 클래스들은 인터페이스의 `getTitle()` 메소드를 각각 구현한다.
  - 구현체에 따라 각각 다른 `getTitle()` 메소드가 호출될 것이다.

이는 다형성을 활용하는 좋은 방법이다. 또한, 클라이언트가 대상 객체가 프록시인지 아닌지 구분하지 않아도 된다.

**📌 비지터 패턴 사용**<br/>
<img src="https://leejaedoo.github.io/assets/img/visitor.jpg" width="40%">

- 비지터 패턴은 `Visitor` 와 이를 받아들이는 대상 클래스로 구분된다.
  - 여기서 `Item` 은 비지터를 받아들이기만 하고, 실제 로직은 비지터가 처리한다.
- `Visitor` 에는 `visit()` 라는 메소드를 정의하고, 모든 대상 클래스를 받아들이도록 작성한다.
- 대상 클래스는 `accept(visitor)` 메소드를 추가해 비지터를 받아들일 수 있도록 한다. 
  - 단순히 파라미터로 넘어온 `Visitor` 의 `visit(this)` 메소드를 호출해 자신을 파라미터로 넘긴다. 
  - 따라서 **실제 로직 처리를 비지터에 위임**한다.

비지터 패턴을 사용하면 
- 프록시에 대한 걱정 없이 안전하게 원본 엔티티에 접근할 수 있고,
- `instanceof` 나 타입 캐스팅 없이 코드를 구현할 수 있다.
- 알고리즘과 객체 구조를 분리해 구조를 수정하지 않고 새로운 동작을 추가할 수 있다.

하지만 단점으로는
- 너무 복잡하고 더블 디스패치를 사용하기에 이해가 어렵다.
- 객체 구조가 변경되면 모든 `Visitor` 를 수정해야 한다.

> **더블 디스패치**는 다중 디스패치의 특수한 형태로, 호출에 관련된 두 객체의 런타임 유형에 따라 다른 구체적인 함수에 함수 호출을 보내는 메커니즘이다.

---

## 💫 성능 최적화
### ➰ N + 1 문제
JPA 개발 시 성능상 가장 주의해야 하는 문제이다.

```java
@Entity
public class Member {

  @Id @GeneratedValue
  private Long id;

  @OneToMany(mappedBy = "member", fetch = FetchType.EAGER)
  private List<Order> orders = new ArrayList<>();
  ...

}
```

```java
@Entity
@Table(name = "ORDERS")
public class Order {

  @Id @GeneratedValue
  private Long id;

  @ManyToOne
  private Member member;
  ...

}
```

- 회원과 주문 정보는 1:N, N:1 양방향 연관관계다. 그리고 회원이 참조하는 주문정보를 즉시 로딩으로 설정했다.

**📌 즉시 로딩과 N + 1**<br/>
특정 회원 하나를 조회하면 즉시 로딩으로 설정한 주문 정보도 함께 조회한다.
- SQL을 두 번 실행하는 것이 아닌 **조인을 사용해 한 번의 SQL**로 함께 조회한다.
- 하지만 JPQL을 사용하게 되면, JPA는 이를 분석해 SQL을 생성한다. 이때는 즉시 로딩과 지연 로딩에 대해 고려하지 않고 오직 JPQL만 사용해 SQL을 생성한다. 
  - SQL의 결과로 먼저 회원 엔티티를 애플리케이션에 로딩한다.
  - 이와 연관된 주문 컬렉션이 즉시 로딩이므로 JPA는 즉시 로딩을 위해 `ORDERS` 에 대한 SQL을 추가로 실행한다.
  - 총 2번의 SQL을 실행하는데, 만약 조회된 회원이 여러 명인 경우 각 회원에 대해 2번씩 실행하게 된다. 이러한 문제를 **N + 1 문제**라 한다.

**📌 지연 로딩과 N + 1**<br/>
지연 로딩으로 설정하게 되면, JPQL에서는 N + 1 문제가 발생하지 않는다.
- 문제는 모든 회원에 대해 연관된 엔티티를 사용할 때 발생한다.
  - 연관된 엔티티를 초기화하는 수만큼 SQL이 실행될 수 있다. 결국 N + 1 문제가 발생하게 되고, 즉시 로딩과 지연 로딩 모두 발생할 수 있다.

**📌 페치 조인 사용**<br/>
N + 1 문제를 해결하는 가장 일반적인 방법이다. 
- SQL 조인을 사용해 연관된 엔티티를 함께 조회해 문제가 발생하지 않는다.

**📌 Hibernate @BatchSize**<br/>
`@BatchSize` annotation을 사용해 연관된 엔티티를 조회할 때 지정한 `size` 만큼 SQL의 IN 절을 사용해서 조회한다.
- 만약 조회한 회원이 10명인데, `size=5` 로 지정하면 2번의 SQL만 추가로 실행한다.
- 즉시 로딩의 경우, 조회 시점에 SQL이 2번 실행되고
- 지연 로딩의 경우, 엔티티 최초 사용 시점에 1번의 SQL을 실행해 5건의 데이터를 로딩하고, 6번째 데이터 사용 시 1번의 SQL을 추가로 실행한다.

**📌 Hibernate @Fetch(FetchMode.SUBSELECT)**<br/>
`@Fetch` annotation에 `FetchMode` 를 `SUBSELECT` 로 사용하여 연관된 데이터를 조회할 때 서브 쿼리를 사용해 N + 1 문제를 해결할 수 있다.

**📌 N + 1 정리**<br/>
즉시 로딩이 아닌 지연 로딩을 사용하는 것을 추천한다. 성능 최적화가 필요한 곳에는 JPQL 페치 조인을 사용한다.

JPA의 글로벌 페치 전략 기본값은 다음과 같다.
- `@OneToOne` , `@ManyToOne` : 즉시 로딩
- `@OneToMany` , `@ManyToMany` : 지연 로딩

### ➰ 읽기 전용 쿼리의 성능 최적화
엔티티가 영속성 컨텍스트에 관리되어 1차 캐시부터 변경 감지까지 여러 장점들이 있지만, 결국 더 많은 메모리를 사용한다는 단점이 있다.
- 전체 구매 내용을 출력하는 단순한 조회 화면이 있다고 가정한다.
  - 조회한 엔티티를 다시 조회할 일도 없고, 수정할 일도 없이 딱 1번만 읽어서 화면에 출력하면 된다.
  - 읽기 전용으로 엔티티를 조회해 메모리 사용량을 최적화할 수 있다.

다음 JPQL 쿼리를 최적화해보자.
```sql
select o from Order o
```

**📌 스칼라 타입으로 조회**<br/>
엔티티가 아닌 스칼라 타입으로 모든 필드를 조회하는 것이다.
- 스칼라 타입은 영속성 컨텍스트가 결과를 관리하지 않는다.

```sql
select o.id, o.name, o.price from Order p
```

**📌 읽기 전용 쿼리 힌트 사용**<br/>
Hibernate 전용 힌트인 `readOnly` 를 사용해 엔티티를 읽기 전용으로 조회한다.
- 영속성 컨텍스트는 스냅샷을 보관하지 않아 메모리 사용량 최적화가 가능하다.
- 단, 스냅샷이 없어지므로 변경 감지는 제공되지 않는다.

```java
TypedQuery<Order> query = em.createQuery("select o from Order o", Order.class);
query.setHint("org.hibernate.readOnly", true);
```

**📌 읽기 전용 트랜잭션 사용**<br/>
트랜잭션에 `readOnly = true` 옵션을 사용해 Hibernate 세션의 플러시 모드를 MANUAL로 설정한다.
- 강제로 플러시를 호출하지 않는 한 플러시가 발생하지 않는다.
- 즉, 트랜잭션 커밋해도 영속성 컨텍스트를 플러시하지 않는다.

**📌 트랜잭션 밖에서 읽기**<br/>
트랜잭션 없이 엔티티를 조회한다는 의미이다. 물론 JPA에서 데이터를 변경하려면 트랜잭션은 필수다. 
- 조회가 목적일 때만 사용해야 한다.
- 트랜잭션이 없으므로 플러시가 일어나지 않아 조회 성능을 향상시킬 수 있다.

> 기본적으로 플러시 모드는 AUTO로 설정되어 있다. 따라서 트랜잭션을 커밋하거나 쿼리를 실행하면 플러시가 작동한다. 
> - 트랜잭션 자체가 없어지면 커밋할 일이 없다.
> - 또한 JPQL 쿼리도 트랜잭션 없이 실행하면 플러시를 호출하지 않는다.

> **읽기 전용 트랜잭션과 읽기 전용 쿼리 힌트를 동시에 사용하는 것이 가장 효과적이다!**

### ➰ 배치 처리
수 백만 건의 더ㅔ이터를 배치 처리해야 하는 상황에는 적절한 단위로 영속성 컨텍스트를 초기화해야 메모리 부족 오류가 발생하지 않을 것이다.

**📌 JPA 등록 배치**<br/>
반복문을 이용해 특정 개수의 엔티티 저장을 처리할 때마다 플러시를 호출하고, 영속성 컨텍스트를 초기화한다.

수정 배치 처리는 2가지 방법을 주로 사용한다.
- **페이징 처리**: 데이터베이스 페이징 기능을 사용한다.
- **커서**: 데이터베이스가 지원하는 커서 기능을 사용한다.

**📌 JPA 페이징 배치 처리**<br/>
한 번에 특정 개수만큼의 데이터를 페이징 쿼리로 조회하면서 특정 필드의 값을 수정한다.
- 페이지 단위마다 영속성 컨텍스트를 플러시하고 초기화한다.

JPA는 JDBC 커서를 지원하지 않는다.
- 따라서 **Hibernate 세션**을 사용해 커서를 사용해야 한다.

> **커서**: 일련의 데이터에 순차적으로 액세스할 때 검색 및 "현재 위치"를 포함하는 데이터 요소

**📌 Hibernate scroll 사용**<br/>
Hibernate는 `scroll` 이라는 이름으로 JDBC 커서를 지원한다.
- 먼저 `em.unwrap()` 메소드로 Hibernate 세션을 구한다.
- 쿼리를 조회하면서 `scroll()` 메소드로 `ScrollableResults` 객체를 반환받는다.
  - 이 객체의 `next()` 메소드를 호출하면 엔티티를 하나씩 조회할 수 있다.

**📌 Hibernate 무상태 세션 사용**<br/>
무상태 세션은 영속성 컨텍스트를 만들지 않고 심지어 2차 캐시도 사용하지 않는다.
- 엔티티를 수정하려면 무상태 세션이 제공하는 **`update()` 메소드를 직접 호출**해야 한다.

### ➰ SQL 쿼리 힌트 사용
JPA는 데이터베이스 SQL 힌트 기능을 제공하지 않는다. SQL 힌트를 사용하려면 Hibernate를 직접 사용해야 한다.
- SQL 힌트는 Hibernate 쿼리가 제공하는 `addQueryHint()` 메소드를 사용한다.

### ➰ 트랜잭션을 지원하는 쓰기 지연과 성능 최적화
**📌 트랜잭션을 지원하는 쓰기 지연과 JDBC 배치**<br/>
네트워크 호출 한 번은 단순한 메소드를 수만 번 호출하는 것보다 더 많은 비용이 든다.
- JDBC가 제공하는 SQL 배치 기능을 사용하면 SQL을 모아서 데이터베이스에 한 번에 보낼 수 있다.
  - 하지만 이는 코드의 많은 수정을 요구한다.
  - 그래서 보통 수백 수천 건 이상의 데이터를 변경하는 특수한 상황에 이를 사용한다.
- `hibernate.jdbc.batch_size` 속성의 값을 변경시켜 SQL 배치 실행 시 모을 데이터의 수를 지정할 수 있다.
  - SQL 배치는 같은 SQL일 때만 유효하다.

> 엔티티를 데이터베이스에 저장해야 식별자를 구할 수 있는 IDENTITY 식별자 생성 전략은 쓰기 지연을 활용한 성능 최적화를 할 수 없다.

**📌 트랜잭션을 지원하는 쓰기 지연과 애플리케이션 확장성**<br/>
트랜잭션을 지원하는 쓰기 지연과 변경 감지 기능 덕에 **데이터베이스 테이블 로우에 락이 걸리는 시간을 최소화**할 수 있다.
- 트랜잭션을 커밋해서 영속성 컨텍스트를 플러시하기 전까지는 데이터베이스에 데이터를 등록, 수정, 삭제하지 않는다.
- 따라서 커밋 직전까지 데이터베이스 로우에 락을 걸지 않는다.

JPA는 커밋을 해야 플러시를 호출하고 데이터베이스에 수정 쿼리를 보낸다.
- 쿼리를 보내고 바로 트랜잭션을 커밋하므로 결과적으로 데이터베이스에 락이 걸리는 시간을 최소화한다.
  - 동시에 더 많은 트랜잭션을 처리할 수 있게 하는 장점이다.

## 📕 출처
- [더블 디스패치](https://en.wikipedia.org/wiki/Double_dispatch)
- [커서](https://ko.wikipedia.org/wiki/%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B2%A0%EC%9D%B4%EC%8A%A4_%EC%BB%A4%EC%84%9C)
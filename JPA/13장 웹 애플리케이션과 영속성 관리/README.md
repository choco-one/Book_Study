> 컨테이너 환경에서 JPA가 동작하는 내부 동작 방식에 대해 이해하는 장이다.

## 💫 트랜잭션 범위의 영속성 컨텍스트
순수한 J2SE 환경에서 JPA를 사용하면, 개발자가 직접 엔티티 매니저를 생성하고 트랜잭션도 관리해야 한다. 
- 하지만 스프링이나 J2EE 컨테이너 환경에서 JPA를 사용하면 컨테이너가 제공하는 전략을 따라야 한다.

### ➰ 스프링 컨테이너의 기본 전략
**트랜잭션 범위의 영속성 컨텍스트 전략**이 기본이다.
- 트랜잭션의 범위와 영속성 컨텍스트의 생존 범위가 같다는 의미이다. (트랜잭션을 시작할 때 영속성 컨텍스트를 생성하고, 트랜잭션이 끝날 때 영속성 컨텍스트를 종료한다.)
- 한 트랜잭션 안에서는 항상 같은 영속성 컨텍스트에 접근한다.

<img src="https://user-images.githubusercontent.com/45073750/141610903-843ccefe-e8c7-41da-8948-0c2e4d5f6cb6.png" width="
60%">

- 스프링 프레임워크에서는 보통 비즈니스 로직을 시작하는 서비스 계층에 `@Transactional` annotation을 선언해 트랜잭션을 시작한다. 
  - 호출한 메소드를 실행하기 직전에 **스프링 트랜잭션 AOP**가 먼저 동작한다.
- 스프링 트랜잭션 AOP는 대상 메소드를 호출하기 직전에 트랜잭션을 시작하고, 메소드가 정상 종료되면 트랜잭션을 커밋하면서 종료한다.
  - 트랜잭션을 커밋하면 JPA는 먼저 **영속성 컨텍스트를 플러시**해서 변경 내용을 데이터베이스에 반영한 후 **데이터베이스 트랜잭션을 커밋**한다. (영속성 컨텍스트의 변경 내용이 반영)
- 예외 발생 시, 트랜잭션 롤백 후 종료한다. (플러시 호출 X)

> `javax.persistence.PersistenceContext` annotation을 사용하면, 스프링 컨테이너가 엔티티 매니저를 주입해준다.

컨트롤러가 호출한 서비스의 메소드를 사용하는 예시이다.
1. `Service.logic()` 메소드에 `@Transactional` 을 선언해서 메소드 호출 시 트랜잭션을 먼저 시작한다.
2. `logic()` 에서 사용하는 `repository.findMember()` 를 통해 조회한 `member` 엔티티는 트랜잭션 범위 안에 있어 영속성 컨텍스트의 관리를 받는다. (즉 영속 상태)
3. `@Transactional` 을 선언한 메소드가 정상 종료되면 트랜잭션을 커밋하는데, 이때 영속성 컨텍스트도 종료한다. (즉 조회한 엔티티는 이제 준영속 상태)
4. 서비스 메소드가 끝나면서 트랜잭션과 영속성 컨텍스트가 종료, 따라서 컨트롤러에 반환된 엔티티는 준영속 상태이다.

**📌 트랜잭션 범위의 영속성 컨텍스트 전략**
- "트랜잭션이 같으면 같은 영속성 컨텍스트를 사용한다."
  - 다양한 위치에서 엔티티 매니저를 주입받아 사용해도 트랜잭션이 같다면 항상 같은 영속성 컨텍스틀 사용한다. 
- "트랜잭션이 다르면 다른 영속성 컨텍스트를 사용한다."
  - 여러 스레드에서 동시에 요청이 와서 같은 엔티티 매니저를 사용해도 트랜잭션에 따라 접근하는 영속성 컨텍스트가 다르다.
    - 스프링 컨테이너가 스레드마다 각각 다른 트랜잭션을 할당하기 때문이다.

---

## 💫 준영속 상태와 지연 로딩
트랜잭션 범위의 영속성 컨텍스트 전략을 사용하기에, 조회한 엔티티가 서비스와 레포지토리 계층에서는 영속성 컨텍스트에 관리되면서 영속 상태를 유지하지만 컨트롤러나 뷰 같은 프레젠테이션 계층에서는 준영속 상태가 된다.
- 따라서 프레젠테이션 계층에서는 엔티티에 대한 변경 감지와 지연 로딩이 동작하지 않는다. (컨트롤러에서 엔티티에 대한 지연 로딩 시점에 예외 발생)

**📌 준영속 상태와 변경 감지**<br/>
변경 감지 기능은 영속상태의 엔티티에 대해서만 가능하고, 보통 서비스 계층에서 비즈니스 로직을 수행하면서 발생한다.
- 단순히 보여주기만 하는 프레젠테이션 계층에서 데이터를 수정할 일은 거의 없고, 오히려 변경 감지가 동작한다면 애플리케이션의 유지보수에 어려움을 더한다.

> 변경 감지 기능이 프레젠테이션 계층에서 동작하지 않는 것은 서로의 책임을 확실히 하는데 당연한 것이다.

- `spring-data-jpa`

**📌 준영속 상태와 지연 로딩**<br/>
준영속 상태의 가장 문제는 지연 로딩 기능이 동작하지 않는다는 것이다.
- 뷰 렌더링 시, 연관된 엔티티도 함께 사용해야 하는데 연관된 엔티티를 지연 로딩으로 설정해서 프록시 객체로 조회했다고 가정한다.
  - 아직 초기화하지 않는 프록시 객체를 사용하면 실제 데이터를 불러오기 위해 초기화를 시도한다.
  - 하지만 준영속 상태에서는 지연 로딩을 할 수 없어 시도하게 되면 문제가 발생한다. (Hibernate의 경우 `LazyInitializationException` 예외 발생)

이에 대한 해결책은 2가지가 있다.
- 뷰가 필요한 엔티티를 미리 로딩해두는 방법
- OSIV를 사용해 엔티티를 항상 영속 상태로 유지하는 방법

첫 번째 방법은 이름 그대로 영속성 컨텍스트가 살아 있을 때 뷰에 필요한 엔티티들을 미리 다 로딩하거나 초기화해서 반환하는 방법이다.
- 엔티티가 준영속 상태로 변해도 연관된 엔티티를 이미 다 로딩해 둔 상태이므로 지연 로딩이 필요하지 않다.
- 어디서 미리 로딩하느냐에 따라 3가지 방법으로 나뉜다.
  - 글로벌 페치 전략 수정
  - JPQL 페치 조인
  - 강제로 초기화

### ➰ 글로벌 페치 전략 수정
글로벌 페치 전략을 지연 로딩에서 즉시 로딩(`FetchType.EAGER`)으로 변경하면 된다.
- 엔티티에 있는 페치 타입을 변경하여 애플리케이션 전체에서 이 엔티티를 로딩할 때마다 해당 전략을 사용하도록 한다. (글로벌 페치 전략)

**📌 글로벌 페치 전략에 즉시 로딩 사용 시 단점**<br/>
- 사용하지 않는 엔티티를 로딩한다.
- N + 1 문제가 발생한다.
  - 즉시 로딩인 경우 엔티티 조회 시 데이터베이스에 JOIN 쿼리를 사용해 한 번에 연관된 엔티티까지 조회한다.
  - 문제는 JPQL 사용 시 발생한다. 즉시 로딩으로 설정하고 JPQL로 조회하면, **JPA가 JPQL을 분석해 SQL을 생성할 떄는 글로벌 페치 전략을 참고하지 않고, 오직 JPQL 자체만 사용한다.**
  - 조회한 엔티티가 10개이면, 이와 연관된 엔티티를 조회하는 SQL도 10번 실행한다.
    - 이처럼 처음 조회한 데이터 수만큼 다시 SQL을 사용해 조회하는 것을 N + 1 문제라 한다.

> N + 1이 발생하면 SQL이 많이 호출되어 조회 성능에 치명적이다. 이는 **JPQL 페치 조인으로 해결**할 수 있다. 

### ➰ JPQL 페치 조인
JPQL을 호출하는 시점에 함께 로딩할 엔티티를 선택할 수 있는 페치 조인이다.

```java
// 페치 조인 사용 전
JPQL: select o from Order o
SQL: select * from Order
```
```java
// 페치 조인 사용 후
JPQL: select o.*, m.*
      from Order o
      join fetch o.member
SQL: select o.*, m.*
     from Order o
     join Member m on o.MEMBER_ID = m.MEMBER_ID
```
- 페치 조인을 사용하면 SQL JOIN을 사용해서 페치 조인 대상까지 함께 조회하므로, N + 1 문제가 발생하지 않는다.

**📌 JPQL 페치 조인의 단점**<br/>
현실적인 대안이지만, 무분별하게 사용하면 화면에 맞춘 레포지토리 메소드가 증가할 수 있다. (프레젠테이션 계층이 알게 모르게 데이터 접근 계층을 침범하는 것이다.)
- 화면 A는 특정 엔티티만 필요하고, 화면 B는 특정 엔티티와 연관된 엔티티 둘 다 필요한 경우, 두 화면을 모두 최적화하기 위해 둘을 지연 로딩으로 설정하고 레포지토리에 각 화면에 맞춘 메소드를 생성한다.
  - 각 화면들은 필요한 메소드를 호출하면 된다. 이렇게 최적화는 가능하지만, **뷰와 레포지토리 간 논리적인 의존관계가 발생**하게 된다.

> 무분별한 최적화로 논리적인 의존관계를 증가시키지 않고 적절하게 타협하는 것이 합리적이다.

### ➰ 강제로 초기화
영속성 컨텍스트가 살아있을 때 프레젠테이션 계층이 필요한 엔티티를 강제로 초기화해서 반환하는 방법이다.

```java
class OrderService {

  @Transactional
  public Order findOrder(Long id) {
    Order order = orderRepository.findOrder(id);
    order.getMember().getName(); // 프록시 객체를 강제로 초기화한다.
    return order;
  }
}
```
- 글로벌 페치 전략을 지연 로딩으로 설정한다. 연관된 엔티티를 실제 엔티티가 아닌 프록시 객체로 조회하게 된다. 
  - **프록시 객체는 실제 사용하는 시점에 초기화**된다. 
  - 그런데 위 예시처럼, 프레젠테이션 계층에서 필요한 프록시 객체를 **영속성 컨텍스트가 살아있을 때 강제로 초기화해서 반환**하면, 이미 초기화되었기에 **준영속 상태에서도 사용**할 수 있게 된다.

예제처럼 프록시 초기화를 서비스 계층이 담당하면, 뷰가 필요한 엔티티에 따라 서비스 계층의 로직을 변경해야 한다.
- **프레젠테이션 계층이 서비스 계층을 침범하게 된다.**
- 프록시 초기화 역할을 분리해야 하는데, FACADE 계층이 그 역할을 담당한다.

### ➰ FACADE 계층 추가
프레젠테이션 계층과 서비스 계층 사이에 추가한다. 이제 뷰를 위한 프록시 초기화는 이 계층에서 담당한다. (논리적인 의존성을 제거!)
- 프록시 초기화를 위해서는 영속성 컨텍스트가 필요하므로, FACADE에서 트랜잭션을 시작해야 한다.

**📌 FACADE 계층의 역할과 특징**<br/>
- 프레젠테이션 계층에서 필요한 프록시 객체를 초기화한다.
  - 프레젠테이션 계층과 도메인 모델 계층 간의 논리적 의존성을 분리해준다.
- 서비스 계층을 호출해서 비즈니스 로직을 실행한다.
- 레포지토리를 직접 호출해서 뷰가 요구하는 엔티티를 찾는다.

실용적인 관점에서 보면, **중간에 계층이 하나 더 끼어든다**는 단점이 있다.
- 더 많은 코드를 작성하게 한다.
- 그리고 FACADE에는 단순히 서비스 계층을 호출만 하는 위임 코드가 상당히 많을 것이다.

### ➰ 준영속 상태와 지연 로딩의 문제점
뷰를 개발할 때 필요한 엔티티를 미리 초기화하는 방법은 생각보다 오류가 발생할 가능성이 높다.
- 엔티티 클래스를 보고 개발하지 더 세세하게 다른 클래스를 확인하는 것은 번거롭고 놓치기 쉽기 때문이다.

그리고 애플리케이션 로직과 뷰가 물리적으로는 나누어져 있지만 논리적으로 서로 의존한다는 문제가 있다. (FACADE 계층을 사용해서 해결할 수는 있지만 번거로움)

> 결국 모든 문제는 **엔티티가 프레젠테이션 계층에서 준영속 상태이기 때문에 발생**한다. 영속성 컨텍스트를 뷰까지 살아있도록 열어두어 지연 로딩을 사용할 수 있게 하자. 이것이 OSIV다.

---

## 💫 OSIV
OSIV(Open Session In View)는 영속성 컨텍스트를 뷰까지 열어둔다는 뜻이다. 즉, 뷰에서도 지연 로딩을 사용할 수 있다.

### ➰ 과거 OSIV: 요청 당 트랜잭션
가장 단순한 구현 방법은 클라이언트의 요청이 들어오자마자 서블릿 필터나 스프링 인터셉터에서 트랜잭션을 시작하고 요청이 끝날 떄 트랜잭션도 끝내는 것이다.
- 영속성 컨텍스트가 처음부터 끝까지 살아있으므로 조회한 엔티티도 영속 상태를 유지한다.
- 뷰에서도 지연 로딩을 할 수 있다.

**📌 요청 당 트랜잭션 방식의 OSIV 문제점**<br/>
"컨트롤러나 뷰 같은 프레젠테이션 계층이 엔티티를 변경할 수 있다"는 점이다.
- 뷰에 노출할 때만 엔티티의 값을 변경하고자 하고, 실제 데이터베이스의 값은 변경하기 원치 않는 경우가 있다.
- 하지만 이 방식은 뷰를 렌더링한 후 트랜잭션을 커밋한다.
  - 당연히 영속성 컨텍스트를 플러시하게 되고, 변경 감지 기능으로 인해 데이터베이스에 변경 사항이 반영되어 버린다.

프레젠테이션 계층에서 이렇게 데이터를 변경해 반영해버리면, 애플리케이션의 유지보수를 매우 어렵게 한다.
- 그렇다면 엔티티를 수정하지 못하게 막으면 되는데, 아래 3가지 방법이 있다.

1. 엔티티를 읽기 전용 인터페이스로 제공
2. 엔티티 Wrapping
3. DTO만 반환

**📌 엔티티를 읽기 전용 인터페이스로 제공**<br/>
엔티티를 직접 노출하는 대신에 읽기 전용 메소드만 제공하는 인터페이스를 프레젠테이션 계층에 제공하는 방법이다.
- 프레젠테이션 계층은 읽기 전용 메소드만 있는 인터페이스를 사용해 엔티티를 수정할 수 없다!

**📌 엔티티 Wrapping**<br/>
엔티티의 읽기 전용 메소드만 가지고 있는 엔티티를 감싼 객체를 만들고 이를 프레젠테이션 계층에 반환하는 방법이다.

```java
class MemberWrapper {

  private Member member;

  public MemberWrapper(Member member) {
    this.member = member;
  }

  public String getName() {
    member.getName();
  }
}
```

**📌 DTO만 반환**<br/>
프레젠테이션 계층에 엔티티 대신에 단순히 데이터만 전달하는 객체인 DTO(Data Transfer Object)를 생성해서 반환하는 것이다.
- OSIV를 사용하는 장점을 살릴 수 없고, 엔티티를 거의 복사한 듯한 DTO 클래스도 하나 더 만들어야 한다.

> 모두 코드량이 상당히 증가한다는 단점이 있는 방법들이다. 최근에는 비즈니스 계층에서만 트랜잭션을 유지하는 방식의 OSIV를 사용한다. 

### ➰ 스프링 OSIV: 비즈니스 계층 트랜잭션
스프링 프레임워크가 제공하는 OSIV다.

**📌 스프링 프레임워크가 제공하는 OSIV 라이브러리**<br/>
`spring-orm.jar` 는 다양한 OSIV 클래스를 제공한다. OSIV를 서블릿 필터에서 적용할지 인터셉터에서 적용할지에 따라 원하는 클래스를 선택해서 사용하면 된다.

- Hibernate OSIV 서블릿 필터: `org.springframework.orm.hibernate4.support.OpenSessionInViewFilter`
- Hibernate OSIV 스프링 인터셉터: `org.springframework.orm.hibernate4.support.OpenSessionInViewInterceptor`
- JPA OEIV 서블릿 필터: `org.springframework.orm.jpa.support.OpenEntityManagerInViewFilter`
- JPA OEIV 스프링 인터셉터: `org.springframework.orm.jpa.support.OpenEntityManagerInViewInterceptor`

**📌 스프링 OSIV 분석**<br/>
요청 당 트랜잭션 방식은 프레젠테이션 계층에서 데이터를 변경할 수 있다는 문제가 있다. (당연히 스프링 OSIV에서는 이러한 문제를 어느정도 해결)

"비즈니스 계층에서 트랜잭션을 사용하는 OSIV다!" (OSIV를 사용하기는 하지만 트랜잭션은 비즈니스 계층에서만 사용)

<img src="https://media.vlpt.us/images/agugu95/post/e8220dcf-3d4a-4657-9fb7-b1895c4e5606/image.png" width="60%">

1. 클라이언트의 요청이 들어오면, 서블릿 필터나 인터셉터에서 영속성 컨텍스트를 생성한다. (트랜잭션은 아직 시작하지 않는다.)
2. 서비스 계층에서 `@Transactional` 로 트랜잭션을 시작할 때 1번에서 미리 생성해둔 영속성 컨텍스트를 찾아와서 트랜잭션을 시작한다.
3. 서비스 계층이 끝나면 트랜잭션을 커밋하고, 영속성 컨텍스트를 플러시한다. (트랜잭션은 끝내지만, 영속성 컨텍스트는 종료하지 않는다.)
4. 컨트롤러와 뷰까지 영속성 컨텍스트가 유지되므로 조회한 엔티티는 영속 상태를 유지한다.
5. 서블릿 필터나, 인터셉터로 요청이 돌아오면 영속성 컨텍스트를 종료한다. 플러시를 호출하지 않고 바로 종료한다.

**📌 트랜잭션 없이 읽기**<br/>
"영속성 컨텍스틀 통한 모든 변경은 트랜잭션 안에서 이뤄져야 한다." (그렇지 않다면 `TransactionRequiredException` 예외 발생)
- 변경 없이 **단순한 조회 시에는 트랜잭션이 필요없는데**, 이를 트랜잭션 없이 읽기(Nontranscational reads)라 한다. 
- 프록시를 초기화하는 지연 로딩도 조회 기능이므로 이것이 가능하다.

스프링이 제공하는 OSIV를 사용하면 프레젠테이션 계층에서는 트랜잭션이 없으므로, 엔티티를 수정할 수 없다. 
- 따라서 프레젠테이션 계층에서 엔티티를 수정할 수 있는 기존 OSIV의 단점을 보완했다.
- 그리고, 트랜잭션 없이 읽기를 사용해 프레젠테이션 계층에서 지연 로딩 기능을 사용할 수 있다.

스프링이 제공하는 비즈니스 계층 트랜잭션 OSIV의 특징은 다음과 같다.
- 영속성 컨텍스트를 프레젠테이션 계층까지 유지한다.
- 프레젠테이션 계층에는 트랜잭션이 없으므로 엔티티를 수정할 수 없다.
- 프레젠테이션 계층에는 트랜잭션이 없지만 트랜잭션 없이 읽기를 사용해서 지연 로딩을 할 수 있다.

프레젠테이션 계층에는 영속성 컨텍스트가 유지된다. 프레젠테이션 계층에서 영속성 컨텍스트를 플러시하면, 변경 감지가 동작해 데이터베이스에 변경 사항이 반영될 수 있다. 하지만 다음 2가지 이유로 플러시가 동작하지 않는다.
- 트랜잭션을 사용하는 서비스 계층이 끝날 때 트랜잭션이 커밋되면서 이미 플러시했다. 그리고 요청이 끝나면 플러시 호출 없이 종료한다고 했으므로, 플러시는 발생하지 않는다.
- 강제로 `em.flush()` 해도 트랜잭션 범위 밖이기에 데이터를 수정할 수 없다는 예외가 발생할 것이다.

**📌 스프링 OSIV 주의사항**<br/>
프레젠테이션 계층에서 엔티티를 수정한 직후에 트랜잭션을 시작하는 서비스 계층을 호출하면 문제가 발생한다.

1. 컨트롤러에서 회원 엔티티를 조회하고 이름을 수정했다.
2. 컨트롤러에서 트랜잭션이 있는 비즈니스 로직을 실행했다.
3. 트랜잭션 AOP가 동작하면서 영속성 컨텍스트에 트랜잭션을 시작한다. 이후 2번의 메소드를 실행한다.
4. 메소드가 끝나면 트랜잭션 AOP가 트랜잭션을 커밋하고 영속성 컨텍스트를 플러시한다. 이때 동작하는 변경 감지로 인해 1번의 수정 사항을 데이터베이스에 반영한다.

> 컨트롤러에서 엔티티 수정 후 뷰를 호출하지 않고 트랜잭션이 동작하는 비즈니스 로직을 호출했으므로 문제가 발생한다.

문제 해결을 위한 단순한 방법은 트랜잭션이 있는 비즈니스 로직을 모두 호출하고 나서 엔티티를 변경하면 된다.
- 보통 컨트롤러는 비즈니스 로직을 먼저 호출하고, 그 결과를 조회하는 순서로 실행하므로 이러한 문제는 거의 발생하지 않는다.

또한, 스프링 OSIV는 **같은 영속성 컨텍스트를 여러 트랜잭션이 공유**할 수 있어 이런 문제가 발생한다.
- OSIV를 사용하지 않는 트랜잭션 범위의 영속성 컨텍스트 전략은 트랜잭션의 생명주기와 영속성 컨텍스트의 생명주기가 같아 이런 문제가 발생하지 않는다.

---

## 💫 너무 엄격한 계층
상품을 구매한 후에 구매 결과 엔티티를 조회하려고 컨트롤러에서 레포지토리를 직접 접근한다.

```java
class OrderController {

  @Autowired OrderService orderService;
  @Autowired OrderRepository orderRepository;

  public String orderRequest(Order order, Model model) {
    long Id = orderService.order(order); // 상품 구매

    // 레포지토리 직접 접근
    Order orderResult = orderRepository.findOne(Id);
    model.addAttribute("order", orderResult);
    ...

  }
}
```
```java
@Transactional
class OrderService {

  @Autowired OrderRepository orderRepository;

  public Long order(Order order) {
    ... // 비즈니스 로직
    return orderRepository.save(order);
  }

}
```
```java
class OrderRepository {
  @PersistenceContext EntityManager em;

  public Order findOne(Long id) {
    return em.find(Order.class, id);
  }
}
```
- OSIV를 사용하기 전엔 프레젠테이션 계층에서 사용할 지연 로딩된 엔티티를 **미리 초기화**해야 했다. 그리고 이는 **영속성 컨텍스트가 살아있는** 서비스 계층이나 FACADE 계층이 담당했다.
- OSIV를 사용하면 영속성 컨텍스트의 생명주기를 늘렸기에 이럴 필요가 없다.

> 따라서 단순한 엔티티 조회는 컨트롤러에서 레포지토리를 직접 호출해도 아무런 문제가 없다.

---


## 📕 출처
- **자바 ORM 표준 JPA 프로그래밍** - 김영한
- [[JPA] OSIV와 Spring Framework에서의 OSIV에 대해서](https://bepoz-study-diary.tistory.com/400)
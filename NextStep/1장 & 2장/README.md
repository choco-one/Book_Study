# Chapter 1 & 2
## ⚙️ 테스트와 리팩토링

### main() 메소드를 활용한 테스트의 문제점

- 실제로 서비스를 담당하는 프로덕션 코드 / 프로덕션 코드가 정상적으로 동작하는지 확인하기위한 main()
- 일반적으로 main()의 2가지 목적
    - 프로그래밍을 실행하기위한목적
    - 프로덕션코드가 정상적으로 동작하는지 확인하는 테스트 목적
- 프로덕션 코드와 테스트코드(main()) 코드가 같은 Class 에 위치
- 테스트코드는 서비스 하는시점에 같이 배포할 필요가 없음
    - 이 문제를 해결하기 위해 프로덕션 코드와 테스트 코드를 두개의 클래스로 분리
- main() 메소드 하나에서 프로덕션 코드의 여러 메소드를 동시에 테스트하면 복잡도가 증가하고, main()메소드를 유지하는데 부담이 됨

- 한번에 메소드 하나의 구현에 집중
- 한 메소드를 검사한다고 다른 메소드들을 주석처리 하는것은 불합리한 작업

## JUnit

- 단위 테스트 프레임워크 중 하나
- 내가 관심을 가지는 메소드에 대한 테스트만 가능
- 클래스가 가지는 전체 메소드를 한번에 실행할 수도 있고, 메소드 각각을 실행할 수도 있음
- 현재 내가 구현하고 있는 프로덕션 코드에 집중할 수 있는 효과

- 결과값을 눈이 아닌 프로그램을 통해 자동화 → assertEquals(), assertTrue(), assertFalse(), assertNull(), assertNotNull(), assertArrayEquals() 제공

- @Before 어노테이션을 사용해서 인스턴스를 생성하는 코드를 짜면, 인스턴스를 매 테스트마다 생성하는 것
    - 인스턴스를 매 테스트마다 생성하는 이유는 한 테스트 메소드를 실행한 것이 다른 테스트 메소드를 실행할때 영향을 미칠 수 있기 때문
- @After 어노테이션과 함께 사용하여 매번 초기화, 후처리 작업을 통해 각 테스트 간에 영향을 미치지 않고 독립적인 실행이 가능하도록 지원

- 테스트 클래스의 이름은 프로덕션 클래스 이름에 Test 접미사를 붙이는것이 관례
- 프로덕션 코드와 테스트 코드를 구현하기 위해 클래스를 분리할 뿐만 아니라 최초 소스코드를 관리하는 디렉토리까지 분리

## 3가지 원칙

- **메소드는 한가지의 책임만 가지도록 구현**
- **들여쓰기 깊이를 1단계로 유지**
- **else 쓰지않기**

- 리팩토링을 한 후 주의깊게 봐야할 부분은 private 으로 분리한 메소드가 아니라, public 으로 공개하고있는 메소드가 얼마나 읽기 쉽고, 좋은가가 가장 중요
- 세부 구현은 모두 private 메소드로 분리해 일단 관심사에서 제외하고 public 메소드가 무슨 일을 하는지에 대한 전체 흐름을 쉽게 파악할 수 있도록 하기 위함
- 세부 구현에 집중하도록 하지 않고 논리적인 로직을 쉽게 파악할 수 있도록 구현하는 것이 읽기 좋은 코드
- 요구사항이 변경되면서 메소드 이름, 변수, 이름을 변경하는것 또한 중요한 리팩토링

- 구현 ⇒ 테스트를 통한 결과확인 ⇒ 리팩토링
    - 계속 관심을 가지고 리팩토링하고 싶은 코드로 만들기!
- 리팩토링 할 부분을 찾기 힘들 때, 3가지 원칙을 생각하면서 찾는다면 약간의 힌트를 얻을 수 있음!
- 리팩토링을 통해 소스코드를 개선하는 작업을 하고싶다면 테소트 코드가 뒷받침 되어야 함
    - **테스트와 리팩토링은 동반자 관계!!**

- TDD(테스트 주도 개발)
    - JUnit을 활용해 테스트를 검증하는 방식으로 진행하는 연습을 먼저 한 후에 TDD 를 공부
    - 리팩토링의 첫번째 단계가 프로덕션 코드에 대한 테스트 코드를 만드는 것
    - 외부와의 의존관계가 없는 코드부터 시작하는 것이 좋음!
    - 알고리즘이나 유틸리티 성격의 코드를 구현할 때가 좋음! → 알고리즘을 풀 때 이제 리팩토링을 연습!
